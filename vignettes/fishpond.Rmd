---
title: "Fishpond: DTE and DGE with inferential replicates"
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
author: "Anqi Zhu, Avi Srivastava, Joseph Ibrahim, Rob Patro, Michael Love"
output:
  rmarkdown::html_document:
    highlight: tango
    toc: true
    toc_float: true
vignette: |
  %\VignetteIndexEntry{Fishpond: DTE and DGE with inferential replicates}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- run this document with library(rmarkdown); render("fishpond.Rmd") -->

```{r setup, echo=FALSE, results="hide"}
knitr::opts_chunk$set(tidy=FALSE, cache=FALSE,
                      dev="png",
                      message=FALSE, error=FALSE, warning=FALSE)
```

# Macrophage stimulation experiment

We begin the *fishpond* vignette by loading data from a Bioconductor
Experiment Data package, *macrophage*. The package contains RNA-seq
quantification from 24 RNA-seq samples, which are a subset of the
RNA-seq samples used in a paper, 
Alasoo, et al. "Shared genetic effects on chromatin and gene
expression indicate a role for enhancer priming in immune response",
published in Nature Genetics, January 2018 
[doi: 10.1038/s41588-018-0046-7](https://doi.org/10.1038/s41588-018-0046-7).

The experiment involved treatment of macrophage cell lines from a number
of human donors with IFN gamma, *Salmonella* infection, or both
treatments combined. In this vignette, we will focus on comparing the
IFN gamma stimulated cell lines with the control cell lines,
accounting for the paired nature of the data (cells from the same
donor).

We load the package, and point to the `extdata` directory. For a
typical analysis, the user would just point `dir` to the location on
the machine or cluster where the transcript quantifications are stored
(e.g. the `quant.sf` files).

```{r}
library(macrophage)
dir <- system.file("extdata", package="macrophage")
```

The data was quantified using *Salmon* 0.12.0 against the Gencode v29
human reference transcripts. For more details and all code used for
quantification, refer the *macrophage* package vignette.

Importantly, `--numGibbsSamples 20` was used to generate 20
inferential replicates with *Salmon*'s Gibbs sampler. Inferential
replicates, either from Gibbs sampling or bootstrapping of reads is
required for the *swish* method shown below. We also recommend to use
`--gcBias` when running *Salmon* to protect against common
sample-specific biases present in RNA-seq data.

# Read in the column data from CSV

We start by reading in a CSV with the *column data*, that is,
information about the samples, which are represented as columns of
the *SummarizedExperiment* object we will construct containing the
counts of reads per gene or transcript.

```{r}
coldata <- read.csv(file.path(dir, "coldata.csv"))
head(coldata)
```

We will subset to certain columns of interest, and re-name them for
later.

```{r}
coldata <- coldata[,c(1,2,3,5)]
names(coldata) <- c("names","id","line","condition")
```

# Add a column pointing to your files

`coldata` needs to have a column `files` which specifies the path to
the quantification files. In this case, we've gzipped the
quantification files, so we point to the `quant.sf.gz` file. We make
sure that all the files exist in the location we specified.

```{r}
coldata$files <- file.path(dir, "quants", coldata$names, "quant.sf.gz")
all(file.exists(coldata$files))
```

Two demonstrate a two group comparison, we subset to the "naive" and
"IFNg" groups. This step could be done after running `tximeta` as well.

```{r}
coldata <- coldata[coldata$condition %in% c("naive","IFNg"),]
coldata$condition <- factor(coldata$condition, c("naive","IFNg"))
```


# Read in quants with *tximeta*

We will read in quantification data for some of the samples. First we
load the *SummarizedExperiment* package. We will store out data and
the output of the statistical method in a *SummarizedExperiment*
object. 

```{r}
suppressPackageStartupMessages(library(SummarizedExperiment))
```

We load in the quantification data with `tximeta`:

```{r}
library(tximeta)
se <- tximeta(coldata)
```

We can see that all the assays have been loaded:

```{r}
assayNames(se)
```

`tximeta` loads transcript-level data, although it can later be
summarized to the gene levels:

```{r}
head(rownames(se))
```

We will rename our *SummarizedExperiment* `y` for the statistical
analysis. For speed of the vignette, we subset to the transcripts on
chromosome 1.

```{r}
y <- se
y <- y[seqnames(y) == "chr1",]
```

# Running `swish` at the transcript level

Running `swish` has three steps: scaling the inferential replicates,
labeling the rows with sufficient counts for running differential
expression, and then calculating the statistics. As `swish` makes use
of pseudo-random number generation in breaking ties and in calculating
permutations (through *samr*), to obtain identical results, one needs
to set a random seed before running `swish()`, as we do below:

```{r}
set.seed(1)
library(fishpond)
y <- scaleInfReps(y)
y <- labelKeep(y)
y <- swish(y, x="condition", pair="line")
```

The results are stored in `mcols(y)`:

```{r}
mcols(y)
```

We can see how many transcripts are in a 5% FDR set:

```{r}
table(mcols(y)$qvalue < .05)
```

Of the transcripts in this set, which have the most extreme log2
fold change? Note that often many transcripts will share the same
q-value, so it's valuable to look at the log2 fold change as well (see
further note below on q-values computed by *samr*). The log2 fold
change computed by `swish` is the median over inferential replicates,
and uses a pseudo-count of 5 on the scaled counts, to stabilize
the variance on the fold change from division by small counts.

```{r}
sig.indicator <- mcols(y)$qvalue < .05
table(sig.indicator, sign.lfc=sign(mcols(y)$log2FC))
o.lo <- order(mcols(y)$log2FC * sig.indicator)
o.hi <- order(-mcols(y)$log2FC * sig.indicator)
mcols(y)[head(o.hi),]
```

# Plotting inferential replicates

We can plot the scaled counts for the inferential replicates, and also
group the samples by a covariate, in this case the cell line. The
analysis was paired, so the statistic assessed if the change within
pairs was consistent. Here we plot the 100th top up-regulated
transcript: 

```{r}
plotInfReps(y, idx=o.hi[100], x="condition", cov="line")
```

# Running `swish` at the gene level

We can also run swish at the gene level. First we summarize all of the
data to the gene level, using the `summarizeToGene` function from
*tximeta*. Again, we rename the object for statistical analysis, and
then we subset to the genes on chromosome 1 for the demonstration.

```{r}
gse <- summarizeToGene(se)
y <- gse
y <- y[seqnames(y) == "chr1",]
```

Next we can run the same steps as before. Again we set a random seed
in order to be able to reproduce exact results in the future:

```{r}
set.seed(1)
y <- scaleInfReps(y)
y <- labelKeep(y)
y <- swish(y, x="condition", pair="line")
```

As before, the number of genes in a 1% FDR set:

```{r}
table(mcols(y)$qvalue < .05)
```

As before, finding the genes with the most extreme log2 fold change:

```{r}
sig.indicator <- mcols(y)$qvalue < .05
table(sig.indicator, sign.lfc=sign(mcols(y)$log2FC))
o.lo <- order(mcols(y)$log2FC * sig.indicator)
o.hi <- order(-mcols(y)$log2FC * sig.indicator)
mcols(y)[head(o.hi),]
```

We can plot a particular one of these genes:

```{r}
plotInfReps(y, idx=o.hi[200], x="condition", cov="line")
```

As expected, the highly up-regulated genes are involved in immune
response.

As with *SAMseq* and *SAM*, `swish` makes use of the permutation
plug-in approach for q-value calculation. `swish` directly calls
functions from *samr* to calculate the q-values. One note about this
approach is that provides asymmetric cutoffs for the statistic for
various q-values, unlike methods using a Wald statistic, in which case
$-t$ and $t$ are given the same p-value. If we plot the q-values
against the statistic, or against the log2 fold change, one can see
clusters of genes with the same q-value (because they have the same or
similar statistic). One consequence of this is that, in order to rank
the genes, rather than ranking directly by q-value, it makes more
sense to pick a q-value threshold and then within that set of genes,
to rank by the log2 fold change, as shown above when the code chunk
has `log2FC * sig.indicator`.

```{r fig.height=4}
min(mcols(y)$qvalue, na.rm=TRUE) # min nominal FDR is not 0
par(mfrow=c(1,2))
with(mcols(y), plot(stat, -log10(qvalue)))
with(mcols(y), plot(log2FC, -log10(qvalue)))
```

# Analysis types supported by `swish`

There are currently three types of analysis supported by `swish`:

* Two group analysis
* Two groups with two or more batches
* Two group paired or matched samples

This vignette demonstrated the third in this list, but the other two
can be run by either not specifying any additional covariates, or by
specifying a batch variable with the argument `cov` instead of `pair`.

# Session information

```{r}
sessionInfo()
```
